Problem definition:

I need a program that implements my domain level resolution cubic lattice model of DNA origami and allows it's configurational space to be modeled with various types of MC sampling.

Requirements

The first main requirement is that it implement the model as described under reports/modelsSpecs/domainResModelSpecs.txt. Summarizing in simplified terms, the system is composed of a number of linear chains, one much larger than the rest, which can interact with a simple attractive term that applies when two segments of the chain of complementary identities share the same lattice site, or a hard core repulsive term that translates into any other two segments being not allowed to share the same lattice site. The bonds between adjacent, covalenty bound segments are only flexible in angle, not in length, meaning that they must occupy neighbour lattice sites (n the future I may add energetic penalties for perpinidicular. There is an orientational degree of freedom associated with each segment: a vector that points to one of the neighbour segments. The system has some additional constraints related to this vector. When two segments are bound, the vectors of these segments must be perpindicular. Further, when two contigous segments are bound, if the vector of the first does not point to the second segment, then the vector of the second segment must be 3 turns in the positive direction relative to the vector pointing from the first to the second segment.

I will probably want to try several different MC algorithms with this model. I will start with the simple one bead moves and the pivot algorithm. I can treat any individual binding state of the system as a branched polymer, and sample from it as such. However, each time a binding event occurs, it changes the state and produces a new topology. If I was to continue sampling with this new topology, the binding events would be irreversible, breaking detailed balance and ergodicity. There must also be moves in which the chains are treated fully independently... but that still might not provide the reverse move. After a binding event, should I allow the previous topology to be sampled still? So I can select from two topologies at all times (except at the very start)? Or perhaps it would be simpler to simply say that each time I select a segment for a particular move, I can select to either try to move it as an independent segment or as a unit with it's bound segment. Let's say I'm trying to do a pivot move. I select to move the long chain idependently. These moves will almost never be accepted because they will probably break a bunch of bound states. But this is certainly reversible. Instead I select to move it as a unit with the segment it is bound to at that point. Well but, would the segment as that point even move? If I said let's move everything that must move as a unit, then it would still be reversible. I could select the same segment, unit move, and opposite direction. I will take this approach to start.

I must also sample the orientation vectors. When I am sampling the position, and something rotates, does the vector stay the same, or does it change (in an absolute sense) so that it can remain in the same relative orientation? I would say the latter. Otherwise the unit moves would always fail. I will have some moves that attempt to change these vectors. A segment is selected and a move attempt is made.

While the non-unit moves can lead to the breaking and making of bonds... wait what if in a unit move I form a bond? Say a pivot happens to cause some new bond to form. Then the reverse move is no longer possible. Fuck. I'll deal with the topic I intended to discuss here for now. The non-unit moves can lead to small segments completely breaking from the long chain. If this happens, these segments will completely disapear. However, I will also need moves that bring these short chains back into the system. This will involve randomly selecting a segment and binding the complementary segment to it. The probablility of this event is related to the concentration of the the chain the segment is a part of and the randomly generated conformation of the rest of the segment. Doe I need to keep the probability the binding and unbinding events equal? How would I do this?

How do I deal with the fact that the unit moves can sometimes be non-reversible under the scheme I outlined? Perhaps I can just disallow new bond formation when doing unit moves. Would that change the distribution I am sampling? Moves that would be favourable are now infinitely unfavourable? There are too many things I don't understand about sampling and distrubtions and probability and acceptance. I will need to do more reading and discuss with Alex about this. For now I can still work on the fundamental parts of the program.

The design will be fairly similar to the saw program and the outline of the branched polymer program. Should I use the terminology of origami, or the the more general terminology of polymers? For now I will use the more general terminology. I will have a BoundPolymers object, the output file objects, and simulation objects for different sampling schemes. What will be the datastructure for storing the BoundPolymer state? I can have 2D array for storing lattice positions. I can have another array that stores the associated orientation vectors. I might also consider keeping an array for the vectors that point to the position of the next segment. Actually, should I have a seperate array for each of the individual linear chains involved? And store these in a hash table? Then I could have another array that has segments that are bound. And a hash table that stores the positions as keys and the chain and segment identities as values.

I've changed my mind: I will use the origami terms.

Eventually I will need to have some script to translate a particular configuration of the system to an input file for tikz so that I can visualize the system with more descriptive colours and shapes then possible with vmd.

I forgot about one of the first pratical problems I realized would come with running simulations in uVT: how do I deal with the changing number of chains in the datastructure? In memory it's fine. The hash table doesn't require preknowing what size it is. But storing it to file isn't so easy. The json format is flexible enough, and I could write a custom format in ascii that could be more efficient. But the how do I do the h5md format? Also, how am I storing the identity of the domains? I suppose I could have another array for each chain that has integers which are associated with a particular domain. How do decide if they are complementary? If they are integers, then an array that has identity of the complementary domain as its entry and the index is the first domain.

Will the chains be identified by numbers that are reused as chains leave and enter the bound state? I will need to have some datastructure that stores the domain identities of the staples involved so that they can be created. For each step that I write to file, should I also write the identity arrays, or only write the identity array for a chain when it is updated? I suppose it's not very difficult to change. Well but with h5py I can't delete datasets. So when the chain associated with a dataset disapears, I could have the positions set to NaN or something, until a new staple comes along. At the end the number of datasets will be equal to the number of highest staples that were present at any one time during the simulation. I suppose I only need to store a single number for the identity of the chains when writing to file, as long as I have stored the identities of all possible chains at the start of the file. This can also be set to NaN or something when there are not chains present for that dataset.

One of the flaws of the saw program was the way I was passing the configuration to the output file object. Every iteration, I had to convert from the working structure to an all list structure, but I was only writing every 100 steps or so, and I only needed the configuration for when I was writing. Perhaps I shouldn't have the polymer (here origami) object as an attribute of the output file? I could pass the polymer object from simulation as an argument to polymer, and then only call configuration if needed to update the polymer held by the outpufile object. When implementing in a lower language, I would obviously just change it so that they all point to the same thing.

I supppose the trial moves can potentially be much more complicated now, as it may involve adding a new chain or removing a chain.

I think I should avoid the overcomplicated bond relative coordinate system I was using before to abstract the selection of a direction for the moves.

I guess for one bead moves, a unit move can never form a new bond. So it should be reversible. So to start I can just do one bead moves and non-unit pivots. What about unbinding? Only a non-unit end rotation on a terminal staple domain... well or a non-unit flip on a scaffold domain bound to a staple domain.

I am reraising the question of whether the hdf5 file should reuse the arrays for different staples. Storing stuff is easiest when there are simple arrays that can be added to, rather then some complex data structure that holds everything and is written each step. If I reuse arrays and write NaN for steps when they are unfilled, I still have all the steps before they wre created that don't exist. If I don't reuse arrays, maybe I should write a step array for each chain, to show where it is applicable. When analyzing I would have to check for each iteration over the steps which chains are present. If there are a lot of chains defined, this could become inefficient.

Should each chain have a unique index assigned to it? If I reuse arrays, then yes. If I reuse arrays, I will probably need to write an array for this index and the indentity. For now I think it is easier to not reuse. I guess there is no use for an overal steps array.

I can't decide if I should have the intialization of the origami require an initial file or not. At this point it will always start from a file, so no reason to overcomplicate things. How should I have access to the contents of files work in a format idependent way? I was going to mirror the access to the origami object, but I have to also include the step.

I'm thinking about changing the structure of the positions and orientations to be a dictionary with the unique chain_indices as keys. Maybe it's not necessary. Actually, I guess for the simulation, all I need to do is pick a random index from the current chain list, and then a domain from that. If I add a new chain, I just call the new chain method and tell it the positions and identities. The method can then append to the internal stuctures, including a new unique index. If a chain is deleted, then i just go to the array indices and delete that. I just need to keep a counter to know what the next unique index should be.

In the simulation loop, how should I deal with trial moves before they are accepted? In the case of non-insertion moves, I can just store the chain and domain indices and positions. But in additiont to testing overlaps, I must also test if the twist constraints are also obeyed. I suppose that moving anything also means applying a translation to the associated orientation vectors to keep the relative orientation. I also need to calculate the energy. At this point, since energies are only determined by the binding of domains, it's trivial to calculate the change from the previous step. In the case of particle insertion and deletion moves, I suppose the apply move function can call add/remove chain instead updating the domain and/or orientation positions. Pure orientation moves will require that I only keep track of the new orientations and check the twist constraint.

I suppose for checking the twist constraints, I need to check every pair that changed, including the first and last domain to change with the previous and next domains, respectively. For each pair along each chain, I check if they are part of the same helix. If so, then I check whether the orientation domains obey the twist. I suppose it's just the interface that I need to know. Should I supply the orientations of both domain in question? Or somehow assign the new orientations to the origami object, and undo if they aren't consistent with the constraints. Probably the former.

If I move a domain that is contigous to a domain that is part of the same helix as the next domain, I can end up breaking the twist constraint. When two matching domains overlap, I will need to check whether they are adding to a prexisting helix, and if so, check if the twist constraints are obeyed.

I think trying to force the calling of acceptance and rejection tests from the main simulation loop is silly and inneficient. The individual moves should call the correct test method, and apply the move if it's accepted.

So I will not bother with the one bead moves, or even the pivot stuff. I will instead start with simple chain regrowth as my sampling method. How will this work? I pick a random domain, then pick the short side, and randomly regrow the chain. So I regrow it like a branched polymer, but allow new bonds to form. But then there is no reverse: how to bonds break? Can I have a growing move that doesn't allow bonds to form? Then I would have to have seperate moves that attempt to break and form bonds. But then would I need to keep a list of domains that are near? What if I had chain regrowth that doesn't assume any topology at all? But then it could involve staple unbinding. Could I have chain regrowths that are allowed to make and break bonds unless it is the last bond of the staple? And then a seperate step for unbinding the last bond? Or should the unbining step be able to unbind a staple in any configuration?

So for now I will do particle insertion and deletion steps anywhere in the selected volume, and chain regrowth from one of the scaffold domains to the shortest end, including all staples and holding topology constant. This means I will need to implement periodic boundary conditions.

Where should I deal with the periodic boundary conditions? Probably in the origami object. The simulation's move methods will propose new positions, and check whether those positions are occupied, and check whether twist constraints are satisfied. Should I convert the proposed moves immediately, or only when I go to set the new position? Should I wrap the numpy arrays used for the positions objects so that when vector addition and subtraction is done, the correct results are output? That seems like a good idea. Or perhaps instead I should be thinking of this as extending the array.

I don't want to have to pass max_dimension everytime I create a new periodic position vector. I can't set a constant in this file because it depends on the size of the system. I will probably have the OrigamiSystem object calculate it base on the input system scaffold chain length. I could have it set the max_dimension as a class variable. But that doesn't seem very safe. If I was analyzing the origami systems and was somehow doing two at once, it could mess up the calculations on the first one. Fow now I will just pass it around.

I sort of want a better way of specifying the movetype probabilities than what I did with the saw program. Maybe just with keyword arguments to the init function.

How am I going calculate and save energies?

Should I organize all the sequence function into a sequence object? For now I don't see the point. There would only be one method that would be used publicly, and it would only be used once for each instance. Then the thing would never be touched again. It would only make sense if you needed to calculate partially complimentary sequence.

When randomly selecting a neighbouring lattice site, should I exclude the position occupied by the domain adjacent to the previous domain (being the domain to which the about to be added domain will be connected to)? I don't see why that would be a problem in principle, but it would require extra bookeeping and calculations. I need to have a better way to think about detailed balance in order to be more confident about whether moves obey it, and a way to think about when a different move set that leads to fewer rejections at the cost of more bookeeping is more efficient. For now I will go simple and pick any neighbour domain.

So now I am implementing a variable topology method instead. I'm not sure how to keep track of the proposed staple positions. Should I first scan through and find all the staples that I will need to regrow? Then for each staple, randomly select a starting domain, and then randomly select from the scaffold and other staples one of the available complimentary domains? What if there isn't one? Try again for the other domain? Probably just reject. Is selecting from the complimentary domains only a bias? I don't think so. So I have the starting positions for all the staples. Should I grow the scaffold domain entirely, then go back and do the staples? Or as I grow the scaffold, randomly select at each branch point whether to grow the staple or the domain? Or always grow the staple at each branch point first? Does it even make a difference? I don't think so. So let's grow the scaffold first.

I need a datastructure that stores which staples are bound to which scaffold and staple domains. I could keep a list of bound things. Or I could change the hashable datastructure back to storing the chain and domain indices of all domains bound there. How would the list work? It could have a tuple with domain's indices kept in a tuple. Then I would have to iterate through the list multiple times, as I would check first for staples bound to the scaffold (requiring me to check both tuples in each tuple), and then again for each staple. There should be a more efficient way. I should be able to build a network structure of the topology. Each node can tell if it is bound and what it is bound to. Maybe I should just change the dictionary then. So there is a key for a position. The value is bound or unbound. I could instead have the key be another dictionary, with a key for state, which has the bound or unbound value, and then if bound there are keys for the chain and domain index, as a tuple i guess, that will give as a value the chain domain index tuple for the bound domain.

The staple domains will always be designed not to have complimentary domains to each other, so I never have to consider the possiblility of staples binding staples.

When a domain attempts to bind to another domain, I need to check whether the domains contigous to it are in bound states, and if so, if they also obey the twist constraints. I should probably also have moves that change the orientations of contigous domains at once, otherwise I could end up with weird blockages between certain states.

I have to make sure that when I am looking for bound staples that subtract the energy of all interactions.

If I make a general chain regrowth method, I would have to pass the starting point, and have it return the proposed positions, orientations, and energy. It would be nice if I could intialize those arrays and pass them in, or a pointer to them, and have the function work on them, rather than having to return them. What if I had a method that just proposes a new position and checks all the twist constraints? I would still have to pass back the new position, orientation, and energy. Would it be easier to check the energy at the end?

The way I iterate over the pairs of domains that need to have the twist constraints tested is ugly. I've realized I will also need to know whether to use the new position vector or not. Well wait I can always use it, it's just the orientation I have to be concerned about. I have no choice: I must pass something to tell it which side to check on.

I just realized there is a fundamental flaw in my method: I am checking for occupancy when regrowing the chain without first removing it's original positions. I could add an argument to the check occupancy method to ignore a range of chain domain pairs. I could actually delete the positions from origami system, first holding them in a variable, and upon rejection restore them. I'll try the former first.

Wait fuck. If I allow the scaffold to bind to a staple bound to another part of the scaffold not being regrown, I break detailed balance. Because then when it selects the same scaffold range, it will also regrow that staple. So only staples on the scaffold are allowed to bind.

The former method for occupancy is going to end up making things very complicated. I think it will be easier to keep two copies of the system. When I select a range to regrow, one copy has all those occupancies deleted. Instead of storing positions and occupancies in lists, I can add them to this new object. That way I can run all the checks without akwardly passing new positins and orientations, and having to reorient them. If the move is rejected, the other one is copied to this one. If it is accepted, this one is copied to the other one.

How should I have the deletion work in the trial system? I will open up the remove occupancy method and add checking in it so that it won't fail if position has already been deleted.

The set position method should maybe not change the occupancy. But I don't like that if I was doing a different sort of move that I would have to remember to set both. Well maybe this is uncessary; I can just move setting the positions in the regrowth method after occupancy has been checked.

I wonder if I might add the twist constraint checks in the set position method itself.

Well wait. If the staple is bound to two places on the part of the scaffold being regrown, then starting point will need to be randomly selected.

I could just shift the staple conformations to the new scaffold domain position selected to be the staple binding point. But that would be more work as I would have to write a seperate method that still checks energies and binding and occupancy and stuff.

Is there an assymetry here? About binding. The thing that is grown first gets to bind, while the thing grown after doesn't. What are the implications of this? The scaffold being regrown could bind to some staple on the other part of the scaffold. This domain could also have a staple complimentary to it that is bound to another part of the part of the scaffold being regrown, and thus is being regrown itself. But the staple domain could never take the position where the other staple not being regrown is. So no, there is difference here then. What about the case where the growth domain of the scaffold is now bound to another staple?

Well but wait, it's not like I could grow the staples first anyways. If the selected bound domain is blocked, then the move is rejected. The only thing where there is a choice is which side of the staple to grow first. They would need to both have the same domain for there to be any possible issue. I don't think that would ever happen. The only time there should be multiple domains is when blocking as defined in snodin2015 happens.

Of course, if and when I include binding between not fully complimentary domains, I will have to rethink everything.

Where should I store the number density of the staples? I guess it should probably be something in the input file rather than in the structur file. But I will start by assuming that all staples have equal concentrations.

For adding a new chain, should I have the method not add the occupancies? Unless I want to delete the occupancies after I add it, this seems to be the only option.

I am going to need to be able to access the occupancy by chain and domain index, not just position.

Does it matter that when I insert the staple, I randomly select a domain on the scaffold, but when I delete the staple, I randomly select a staple rather than a domain on the scaffold and checking if it has a staple?

In order to test these fucntions, I will need to create mock functions for the random functions that will give known outputs.

Subtracting periodic vectors is a bit ambigous. As I first implemented it, it would give the difference between two position vectors in the same cell. But I might have the system at the boundary, wrapped to the other side. In that case I would like the difference vector to be pointing to the next vector as if the chain wasn't wrapped. If I am considering things on the same molecule, then I should always unwrap before taking the difference. What if the position vectors I am looking at are not on the same molecule? I could look at differences between molecules in the same cube, or I could look at differences between molecules in different cubes, I could look at the miminal distance. But I suppose in this model I will never care about such differences.

I should still use something else then a direct numpy array for the positions, so that they can be changed more easily later. I can just inherit from np.array for now.

Turns out that inheriting from numpy.ndarray would be a fair bit of work. I will just stick with the bare array for now.

I should document the internal datastructure of OrigamiSystem in the code somehow. And that it maybe isn't the best that I've opened up the add/remove occupancy methods for public use.

It might be good to add some basic sanity checks to OrigamiSystem's init method. Could also add periodic checks for sanity in the simulation.

You need to be clear about the polarity of the sequences you input, as it makes a difference to the hybridization energy.

Things to fix in OrigamiSystem

- make polarity concrete
- fix domain ordering in constraint check methods
- check length of positions, orientations, sequences, etc. consistent
- behaviour of add/delete chain and occupancy
- check that all contiguous domains on neighbouring lattice sites
- behaviour of get_domain_occupancy
- custom exception(s) for sanity check failures

Fuck. I've been thinking 3' to 5', but apparently the convention is 5' to 3'.

If you pass pass a function a vector and operate on it's elements, and return the result to assign to another vector, they will actually be pointing to the same array. The function will change the original array.

The main issue with decoupling the simulation and the origami objects is how to deal with removing occupancies when a section of the chain is being regrown. The simplest interface would probably be to include an ignore list when setting the position of a new domain, but that would complicate the internals of the origami object, and would be much more expensive. I could have the ignore list delete the occupancies, and then only update those that are not in the next call's list. But is that any cleaner then just deleting them directly? No. But I could have a remove position function that deals with it. What about when I am just looking for all bound domains to subtract energies?

I will transfer all constraint checks to the origami object. The new chain method will no longer require positions or orientations. Well but shit maybe it's not a good idea. Say I want to do a rotate vector move. How do I do early rejection if I don't know the state? I would have to generate the vector first, then pass it to set_orientation, which would then check the state. If I open up the state thing, then I will still be double checking state in orientation. But maybe I should start with the more general method, then replace it with a faster method that cuts directly into origami, with the safer way still included in comments. The other option would be to have a method on origami for selecting a random orientation or position. But I don't really want to do that either.

So maybe I'm not sure now.

I can make the twist test only operate on the scaffold chains. Now wait I can't. Because the staple will sometimes be in a contigouos helix with two non contiguous scaffold domains.

So unless I want to store the old positions in a temporary variable or revert back to the constraint check methods taking positions and orientations as arguments, the set_domain_configuration will update it's positions and orientations before checking those constaints, which if violated, cause it to raise an exception. So if I handle the exception and continue outside the method, the object will now have a configuration that violates the constrants. Is that bad practice, even though I will always throw a MoveRejection exception when catching a ConstraintViolation? I think it's fine, because it's making clear that what you just did is fucked. You would have to conviously decide you are okay with a constraint violation. Except that there is an inconsistency in that if the position it is trying to occupy is in a BOUND state, it will exit before updating the state. Maybe they raise different exceptions?

I will be allowing the system to have unassigned positions, but then should I also have a global state that says whether all domains are assigned, or a list of unassigned domains? Probably a good idea.

How would I do a seperate data structure for domain occupancy? A dictionary whose keys are the chain and domain indices, and whose value is another dictionary with the state and identity of the bound domain. Or, I could have a third dictionary that has key value entries only for those domains in a bound state. My issue with the current setup was that if the state is requested by domain for something that has had it's occupancy removed but not it's position it will give an erroneous state. Would it change the efficiency? In the current case, each time I want the occupancy of a domain, I have to access it's position first. In the second, I can cut that step out, but everytime I undergo a binding or unbinding event, I have to modify these two extra dictionaries. But the the modification of the position state dictionary becomes quicker. I think having seperate dictionaries is more clear. Although I suppose I will actually need to make two mods for every binding/unbinding event on the bound_domains dict.

But what about when I want to get the domain occupying a position? I suppose I would only want to do this if it was in an unbound state. Does this call for another dictionary? I suppose when I delete an occupancy it will always be by domain, not by position.

Do I still need explicit state storate with these dictionaries? If the position is a key in unbound_domains, then it is unbound. But then it isn't a key for any of the dictionaries if it is in bound state. There is also no dictionary where the domain is a key if it is in an unbound state.

When I am making the list of existing domains contiguous to both the neighbour and occupying domains, is it faster to check as I go if the domains are part of the same helix, or make the list first and the check if contiguous and immediately then check if twist constraints are obeyed. The first will always require sale helix to be called on all neighbours, while the second would only do so in the worst case. But why don't I just have both checks happen as I iterate through possible neighbours? I had split up the loop because I can check the occupying domain more quickly simply by bhecking if the chain lenghts are not the start or the end (while the growing chain can have one side be in an unassigned state), but for now I will favour readability over a slight increase in speed.

So do I need two ways to remove occupancies? I will always give a domain, but in one case I want to delete the domain entirely, while in the other I just want to unassign it. When adding, I am either skipping from unassigned to bound or going from unbound to bound, but there shouldnt' be ambiguity about what needs to be done given the state. So I just need one add occupancy method.

But it might be more efficient to have specific methods for each possibility.

Should I assume that set configuration will only be called on unassigned domains?

FFFUUU. I've been assuming that I can just say that the states are unassigned for the regrowing chain. But sometimes that isn't true. If I am doing a constant topology sim... but I can still do that with unassigned stuff. But it would be less efficient. So would I just not unassign the domains that are in bound states? Should I not be using unassigned as a state for the domains, but rather only unbound or bound? Well but I think it's fine. Because when I'm doing constant topology sampling, I wouldn't even allow binding at all. So I would just have to save the growth start points for the staples and when I set those domain configurations, it will change the state back to bound.

I don't see any reason to explicity set any state to unassigned. For now just delete the domain_occupancies.

Need to make clear the methods that are top level movetypes and those that are helper methods.

Maybe I should move the unbinding energy stuff to origami object.

When inserting staples I randomly select a scaffold domain to attempt binding to, given a staple domain. But when I regrow a staple, I select a binding point only from the set of scaffold domains it was previously bound to.

For deleting a domain it doesn't really matter where I find the bound domains and subtract the energies. But in the case of regrowing the staples, I already need to loop through and find all the bound domains so that I create the subset for selecting a growth point. So looping through again would seem like a waste. With my new data structures, there is an easier way to find all bound domains: I can direcetly quiry the bound_domains dictionary. For now let's put in the origami object. My driving organizational philosopy is start by making it safe and modular and loosely coupled, and then later maybe break these rules while optimizing, if need be.

Write input file stucture checker for origami __init__ and add safety checks to set_orientation. Lint. Then fix and extend OrigamiSystem tests, write tests for hdf5 input and both output classes (hopefully can copy from saw), and then move to simulation method tests.

I guess I don't really need to write a whole validate method. I can use the set_domain_configuration method as I iterate through the domains in the first place. The only check I have to add in, which can just be in the read in loop, is whether the domains are on adjacent lattice sites. To ensure that all defined domains are assigned positions and orientations, the iteration over domains in a chain should come from the identities list.

What test input structures do I need? Should I just have one that I can manipulate?

HOLY SHIT. I've been thinking about the orientation vectors all wrong. First, since sequences are read 5 to 3', I am actually talking about the 3', not the 5' prime vector. Second, the staple strands are going in the opposite direction, but I am interested in the direction at the start of the strand, as I say they are in the correct oreintation to bind when they orientations of the scaffold and staple strand are opposite. Do I want to instead look at the 3' prime vectors in both cases, and have the binding oreintation be seperated by (-?)pi rather than 2pi? I think I might need to, as otherwise the helical pair constraints for the staples are going to become confusing. Well not necessarily.

I am going to go with setting the orientation vector to be the 3' end on the scaffold and the 5' end on the staple, as that is the way I was thinking about it originally.

Wow, big problem with the dictionaries and deleting chains. I have a bunch of chain indices stored that point to lists that will change when deleting a chain, meaning that they will give incorrect information when used. Perhaps the most straightforward fix is to store the unique indices in these dictionaries, rather than the working indices, and have the get methods use the unique indices to find the working indices. I will then have to use the get methods for all access internally.

So should I just have a dictionary that has a mapping from the unique chain indices to the working indices, and vice versa? I should use the indices list as the working to unique becuase deleting the entry automaticaly updates the list. Then I will just have to update the unique to working dictionary every time a chain is deleted.

It's not so great that I have to remember to unassign the domain before setting the configuration. I should probably add a check for that. But I won't.

So in order for the origami class instance to be copied properly, I need to use copy.deepcopy. I should probably implement a method that will allow the copying to be done more efficiently.

I can have a new helix stick out from an old helix in any direction at the 5' end. That doesn't seem very realistic. What could I introduce to only allow an orientation that is consistent with the twist of old helix? I can cut down to two from four by forcing the angle between the orientational domains to be pi, but there is not way of going to 1 unless you consider the next domain vector. So perhaps I should start keeping track of this as well. It's not that much extra.

For now I'm going to stick with what I have and focus on testing the simulation remaining file objects.

I suppose I could memoization to store the boltzman factors, as I would expect a fair amount of repitition.
