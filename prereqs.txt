Problem definition:

I need a program that implements my domain level resolution cubic lattice model of DNA origami and allows it's configurational space to be modeled with various types of MC sampling.

Requirements

The first main requirement is that it implement the model as described under reports/modelsSpecs/domainResModelSpecs.txt. Summarizing in simplified terms, the system is composed of a number of linear chains, one much larger than the rest, which can interact with a simple attractive term that applies when two segments of the chain of complementary identities share the same lattice site, or a hard core repulsive term that translates into any other two segments being not allowed to share the same lattice site. The bonds between adjacent, covalenty bound segments are only flexible in angle, not in length, meaning that they must occupy neighbour lattice sites (n the future I may add energetic penalties for perpinidicular. There is an orientational degree of freedom associated with each segment: a vector that points to one of the neighbour segments. The system has some additional constraints related to this vector. When two segments are bound, the vectors of these segments must be perpindicular. Further, when two contigous segments are bound, if the vector of the first does not point to the second segment, then the vector of the second segment must be 3 turns in the positive direction relative to the vector pointing from the first to the second segment.

I will probably want to try several different MC algorithms with this model. I will start with the simple one bead moves and the pivot algorithm. I can treat any individual binding state of the system as a branched polymer, and sample from it as such. However, each time a binding event occurs, it changes the state and produces a new topology. If I was to continue sampling with this new topology, the binding events would be irreversible, breaking detailed balance and ergodicity. There must also be moves in which the chains are treated fully independently... but that still might not provide the reverse move. After a binding event, should I allow the previous topology to be sampled still? So I can select from two topologies at all times (except at the very start)? Or perhaps it would be simpler to simply say that each time I select a segment for a particular move, I can select to either try to move it as an independent segment or as a unit with it's bound segment. Let's say I'm trying to do a pivot move. I select to move the long chain idependently. These moves will almost never be accepted because they will probably break a bunch of bound states. But this is certainly reversible. Instead I select to move it as a unit with the segment it is bound to at that point. Well but, would the segment as that point even move? If I said let's move everything that must move as a unit, then it would still be reversible. I could select the same segment, unit move, and opposite direction. I will take this approach to start.

I must also sample the orientation vectors. When I am sampling the position, and something rotates, does the vector stay the same, or does it change (in an absolute sense) so that it can remain in the same relative orientation? I would say the latter. Otherwise the unit moves would always fail. I will have some moves that attempt to change these vectors. A segment is selected and a move attempt is made.

While the non-unit moves can lead to the breaking and making of bonds... wait what if in a unit move I form a bond? Say a pivot happens to cause some new bond to form. Then the reverse move is no longer possible. Fuck. I'll deal with the topic I intended to discuss here for now. The non-unit moves can lead to small segments completely breaking from the long chain. If this happens, these segments will completely disapear. However, I will also need moves that bring these short chains back into the system. This will involve randomly selecting a segment and binding the complementary segment to it. The probablility of this event is related to the concentration of the the chain the segment is a part of and the randomly generated conformation of the rest of the segment. Doe I need to keep the probability the binding and unbinding events equal? How would I do this?

How do I deal with the fact that the unit moves can sometimes be non-reversible under the scheme I outlined? Perhaps I can just disallow new bond formation when doing unit moves. Would that change the distribution I am sampling? Moves that would be favourable are now infinitely unfavourable? There are too many things I don't understand about sampling and distrubtions and probability and acceptance. I will need to do more reading and discuss with Alex about this. For now I can still work on the fundamental parts of the program.

The design will be fairly similar to the saw program and the outline of the branched polymer program. Should I use the terminology of origami, or the the more general terminology of polymers? For now I will use the more general terminology. I will have a BoundPolymers object, the output file objects, and simulation objects for different sampling schemes. What will be the datastructure for storing the BoundPolymer state? I can have 2D array for storing lattice positions. I can have another array that stores the associated orientation vectors. I might also consider keeping an array for the vectors that point to the position of the next segment. Actually, should I have a seperate array for each of the individual linear chains involved? And store these in a hash table? Then I could have another array that has segments that are bound. And a hash table that stores the positions as keys and the chain and segment identities as values.

I've changed my mind: I will use the origami terms.

Eventually I will need to have some script to translate a particular configuration of the system to an input file for tikz so that I can visualize the system with more descriptive colours and shapes then possible with vmd.

I forgot about one of the first pratical problems I realized would come with running simulations in uVT: how do I deal with the changing number of chains in the datastructure? In memory it's fine. The hash table doesn't require preknowing what size it is. But storing it to file isn't so easy. The json format is flexible enough, and I could write a custom format in ascii that could be more efficient. But the how do I do the h5md format? Also, how am I storing the identity of the domains? I suppose I could have another array for each chain that has integers which are associated with a particular domain. How do decide if they are complementary? If they are integers, then an array that has identity of the complementary domain as its entry and the index is the first domain.

Will the chains be identified by numbers that are reused as chains leave and enter the bound state? I will need to have some datastructure that stores the domain identities of the staples involved so that they can be created. For each step that I write to file, should I also write the identity arrays, or only write the identity array for a chain when it is updated? I suppose it's not very difficult to change. Well but with h5py I can't delete datasets. So when the chain associated with a dataset disapears, I could have the positions set to NaN or something, until a new staple comes along. At the end the number of datasets will be equal to the number of highest staples that were present at any one time during the simulation. I suppose I only need to store a single number for the identity of the chains when writing to file, as long as I have stored the identities of all possible chains at the start of the file. This can also be set to NaN or something when there are not chains present for that dataset.

One of the flaws of the saw program was the way I was passing the configuration to the output file object. Every iteration, I had to convert from the working structure to an all list structure, but I was only writing every 100 steps or so, and I only needed the configuration for when I was writing. Perhaps I shouldn't have the polymer (here origami) object as an attribute of the output file? I could pass the polymer object from simulation as an argument to polymer, and then only call configuration if needed to update the polymer held by the outpufile object. When implementing in a lower language, I would obviously just change it so that they all point to the same thing.

I supppose the trial moves can potentially be much more complicated now, as it may involve adding a new chain or removing a chain.

I think I should avoid the overcomplicated bond relative coordinate system I was using before to abstract the selection of a direction for the moves.

I guess for one bead moves, a unit move can never form a new bond. So it should be reversible. So to start I can just do one bead moves and non-unit pivots. What about unbinding? Only a non-unit end rotation on a terminal staple domain... well or a non-unit flip on a scaffold domain bound to a staple domain.

I am reraising the question of whether the hdf5 file should reuse the arrays for different staples. Storing stuff is easiest when there are simple arrays that can be added to, rather then some complex data structure that holds everything and is written each step. If I reuse arrays and write NaN for steps when they are unfilled, I still have all the steps before they wre created that don't exist. If I don't reuse arrays, maybe I should write a step array for each chain, to show where it is applicable. When analyzing I would have to check for each iteration over the steps which chains are present. If there are a lot of chains defined, this could become inefficient.

Should each chain have a unique index assigned to it? If I reuse arrays, then yes. If I reuse arrays, I will probably need to write an array for this index and the indentity. For now I think it is easier to not reuse. I guess there is no use for an overal steps array.

I can't decide if I should have the intialization of the origami require an initial file or not. At this point it will always start from a file, so no reason to overcomplicate things. How should I have access to the contents of files work in a format idependent way? I was going to mirror the access to the origami object, but I have to also include the step.

I'm thinking about changing the structure of the positions and orientations to be a dictionary with the unique chain_indices as keys. Maybe it's not necessary. Actually, I guess for the simulation, all I need to do is pick a random index from the current chain list, and then a domain from that. If I add a new chain, I just call the new chain method and tell it the positions and identities. The method can then append to the internal stuctures, including a new unique index. If a chain is deleted, then i just go to the array indices and delete that. I just need to keep a counter to know what the next unique index should be.

In the simulation loop, how should I deal with trial moves before they are accepted? In the case of non-insertion moves, I can just store the chain and domain indices and positions. But in additiont to testing overlaps, I must also test if the twist constraints are also obeyed. I suppose that moving anything also means applying a translation to the associated orientation vectors to keep the relative orientation. I also need to calculate the energy. At this point, since energies are only determined by the binding of domains, it's trivial to calculate the change from the previous step. In the case of particle insertion and deletion moves, I suppose the apply move function can call add/remove chain instead updating the domain and/or orientation positions. Pure orientation moves will require that I only keep track of the new orientations and check the twist constraint.

I suppose for checking the twist constraints, I need to check every pair that changed, including the first and last domain to change with the previous and next domains, respectively. For each pair along each chain, I check if they are part of the same helix. If so, then I check whether the orientation domains obey the twist. I suppose it's just the interface that I need to know. Should I supply the orientations of both domain in question? Or somehow assign the new orientations to the origami object, and undo if they aren't consistent with the constraints. Probably the former.

If I move a domain that is contigous to a domain that is part of the same helix as the next domain, I can end up breaking the twist constraint. When two matching domains overlap, I will need to check whether they are adding to a prexisting helix, and if so, check if the twist constraints are obeyed.

I think trying to force the calling of acceptance and rejection tests from the main simulation loop is silly and inneficient. The individual moves should call the correct test method, and apply the move if it's accepted.

So I will not bother with the one bead moves, or even the pivot stuff. I will instead start with simple chain regrowth as my sampling method. How will this work? I pick a random domain, then pick the short side, and randomly regrow the chain. So I regrow it like a branched polymer, but allow new bonds to form. But then there is no reverse: how to bonds break? Can I have a growing move that doesn't allow bonds to form? Then I would have to have seperate moves that attempt to break and form bonds. But then would I need to keep a list of domains that are near? What if I had chain regrowth that doesn't assume any topology at all? But then it could involve staple unbinding. Could I have chain regrowths that are allowed to make and break bonds unless it is the last bond of the staple? And then a seperate step for unbinding the last bond? Or should the unbining step be able to unbind a staple in any configuration?

So for now I will do particle insertion and deletion steps anywhere in the selected volume, and chain regrowth from one of the scaffold domains to the shortest end, including all staples and holding topology constant. This means I will need to implement periodic boundary conditions.

Where should I deal with the periodic boundary conditions? Probably in the origami object. The simulation's move methods will propose new positions, and check whether those positions are occupied, and check whether twist constraints are satisfied. Should I convert the proposed moves immediately, or only when I go to set the new position? Should I wrap the numpy arrays used for the positions objects so that when vector addition and subtraction is done, the correct results are output? That seems like a good idea. Or perhaps instead I should be thinking of this as extending the array.

I don't want to have to pass max_dimension everytime I create a new periodic position vector. I can't set a constant in this file because it depends on the size of the system. I will probably have the OrigamiSystem object calculate it base on the input system scaffold chain length. I could have it set the max_dimension as a class variable. But that doesn't seem very safe. If I was analyzing the origami systems and was somehow doing two at once, it could mess up the calculations on the first one. Fow now I will just pass it around.

I sort of want a better way of specifying the movetype probabilities than what I did with the saw program. Maybe just with keyword arguments to the init function.

How am I going calculate and save energies?

Should I organize all the sequence function into a sequence object? For now I don't see the point. There would only be one method that would be used publicly, and it would only be used once for each instance. Then the thing would never be touched again. It would only make sense if you needed to calculate partially complimentary sequence.

When randomly selecting a neighbouring lattice site, should I exclude the position occupied by the domain adjacent to the previous domain (being the domain to which the about to be added domain will be connected to)? I don't see why that would be a problem in principle, but it would require extra bookeeping and calculations. I need to have a better way to think about detailed balance in order to be more confident about whether moves obey it, and a way to think about when a different move set that leads to fewer rejections at the cost of more bookeeping is more efficient. For now I will go simple and pick any neighbour domain.

So now I am implementing a variable topology method instead. I'm not sure how to keep track of the proposed staple positions. Should I first scan through and find all the staples that I will need to regrow? Then for each staple, randomly select a starting domain, and then randomly select from the scaffold and other staples one of the available complimentary domains? What if there isn't one? Try again for the other domain? Probably just reject. Is selecting from the complimentary domains only a bias? I don't think so. So I have the starting positions for all the staples. Should I grow the scaffold domain entirely, then go back and do the staples? Or as I grow the scaffold, randomly select at each branch point whether to grow the staple or the domain? Or always grow the staple at each branch point first? Does it even make a difference? I don't think so. So let's grow the scaffold first.

I need a datastructure that stores which staples are bound to which scaffold and staple domains. I could keep a list of bound things. Or I could change the hashable datastructure back to storing the chain and domain indices of all domains bound there. How would the list work? It could have a tuple with domain's indices kept in a tuple. Then I would have to iterate through the list multiple times, as I would check first for staples bound to the scaffold (requiring me to check both tuples in each tuple), and then again for each staple. There should be a more efficient way. I should be able to build a network structure of the topology. Each node can tell if it is bound and what it is bound to. Maybe I should just change the dictionary then. So there is a key for a position. The value is bound or unbound. I could instead have the key be another dictionary, with a key for state, which has the bound or unbound value, and then if bound there are keys for the chain and domain index, as a tuple i guess, that will give as a value the chain domain index tuple for the bound domain.

The staple domains will always be designed not to have complimentary domains to each other, so I never have to consider the possiblility of staples binding staples.

When a domain attempts to bind to another domain, I need to check whether the domains contigous to it are in bound states, and if so, if they also obey the twist constraints. I should probably also have moves that change the orientations of contigous domains at once, otherwise I could end up with weird blockages between certain states.

I have to make sure that when I am looking for bound staples that subtract the energy of all interactions.

If I make a general chain regrowth method, I would have to pass the starting point, and have it return the proposed positions, orientations, and energy. It would be nice if I could intialize those arrays and pass them in, or a pointer to them, and have the function work on them, rather than having to return them. What if I had a method that just proposes a new position and checks all the twist constraints? I would still have to pass back the new position, orientation, and energy. Would it be easier to check the energy at the end?

The way I iterate over the pairs of domains that need to have the twist constraints tested is ugly. I've realized I will also need to know whether to use the new position vector or not. Well wait I can always use it, it's just the orientation I have to be concerned about. I have no choice: I must pass something to tell it which side to check on.

I just realized there is a fundamental flaw in my method: I am checking for occupancy when regrowing the chain without first removing it's original positions. I could add an argument to the check occupancy method to ignore a range of chain domain pairs. I could actually delete the positions from origami system, first holding them in a variable, and upon rejection restore them. I'll try the former first.

Wait fuck. If I allow the scaffold to bind to a staple bound to another part of the scaffold not being regrown, I break detailed balance. Because then when it selects the same scaffold range, it will also regrow that staple. So only staples on the scaffold are allowed to bind.

The former method for occupancy is going to end up making things very complicated. I think it will be easier to keep two copies of the system. When I select a range to regrow, one copy has all those occupancies deleted. Instead of storing positions and occupancies in lists, I can add them to this new object. That way I can run all the checks without akwardly passing new positins and orientations, and having to reorient them. If the move is rejected, the other one is copied to this one. If it is accepted, this one is copied to the other one.

How should I have the deletion work in the trial system? I will open up the remove occupancy method and add checking in it so that it won't fail if position has already been deleted.

The set position method should maybe not change the occupancy. But I don't like that if I was doing a different sort of move that I would have to remember to set both. Well maybe this is uncessary; I can just move setting the positions in the regrowth method after occupancy has been checked.

I wonder if I might add the twist constraint checks in the set position method itself.

Well wait. If the staple is bound to two places on the part of the scaffold being regrown, then starting point will need to be randomly selected.

I could just shift the staple conformations to the new scaffold domain position selected to be the staple binding point. But that would be more work as I would have to write a seperate method that still checks energies and binding and occupancy and stuff.

Is there an assymetry here? About binding. The thing that is grown first gets to bind, while the thing grown after doesn't. What are the implications of this? The scaffold being regrown could bind to some staple on the other part of the scaffold. This domain could also have a staple complimentary to it that is bound to another part of the part of the scaffold being regrown, and thus is being regrown itself. But the staple domain could never take the position where the other staple not being regrown is. So no, there is difference here then. What about the case where the growth domain of the scaffold is now bound to another staple?

Well but wait, it's not like I could grow the staples first anyways. If the selected bound domain is blocked, then the move is rejected. The only thing where there is a choice is which side of the staple to grow first. They would need to both have the same domain for there to be any possible issue. I don't think that would ever happen. The only time there should be multiple domains is when blocking as defined in snodin2015 happens.

Of course, if and when I include binding between not fully complimentary domains, I will have to rethink everything.

Where should I store the number density of the staples? I guess it should probably be something in the input file rather than in the structur file. But I will start by assuming that all staples have equal concentrations.

For adding a new chain, should I have the method not add the occupancies? Unless I want to delete the occupancies after I add it, this seems to be the only option.

I am going to need to be able to access the occupancy by chain and domain index, not just position.

Does it matter that when I insert the staple, I randomly select a domain on the scaffold, but when I delete the staple, I randomly select a staple rather than a domain on the scaffold and checking if it has a staple?

In order to test these fucntions, I will need to create mock functions for the random functions that will give known outputs.

Subtracting periodic vectors is a bit ambigous. As I first implemented it, it would give the difference between two position vectors in the same cell. But I might have the system at the boundary, wrapped to the other side. In that case I would like the difference vector to be pointing to the next vector as if the chain wasn't wrapped. If I am considering things on the same molecule, then I should always unwrap before taking the difference. What if the position vectors I am looking at are not on the same molecule? I could look at differences between molecules in the same cube, or I could look at differences between molecules in different cubes, I could look at the miminal distance. But I suppose in this model I will never care about such differences.
